#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     LIFT,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     LEFT_DRIVE,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     RIGHT_DRIVE,   tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C3_1,    TUBE_MAN,             tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

const int MAX_JOY_VALUE = 255;
const int MIN_JOY_VALUE = -MAX_JOY_VALUE;

int limitJoy(int value) {
	if (value < MIN_JOY_VALUE) {
		return MIN_JOY_VALUE;
	} else if (value > MAX_JOY_VALUE) {
		return MAX_JOY_VALUE;
	} else {
		return value;
	}
}

// bottom left joystick
void drive(int jx, int jy) {
	const int left = jy + jx;
	const int right = jy - jx;

	motor[LEFT_DRIVE] = left;
	motor[RIGHT_DRIVE] = right;
}

// Y button
void tube_man_up() {
	servo[TUBE_MAN] = 180;
}

// A button
void tube_man_down() {

}

// right joystick
void slide_up(int y) {
}

// right joystick
void slide_down(int y) {

}

// right trigger down
void scoop_tilt_back () { // this is the scoop dumping backwards
}

// right trigger up
void scoop_tilt_fwd () { // this is the scoop tilting forward
}



void handleDriving() {
	drive(limitJoy(joystick.joy1_x1 + joystick.joy2_x1), limitJoy(joystick.joy1_y1 + joystcik.joy2_y1));
}

task main()
{
	initializeRobot ();
  waitForStart ();

  while (true) {
  	getJoystickSettings(joystick);

		handleDriving();


  }

}
